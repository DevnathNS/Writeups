# RSA Labs

First of all, I used the *`file`* command on rsalab.bin and found out that it was executable. Changed the permissions using *`chmod +x`* and executed it using *`./rsalab.bin`*.

1.) Solved the first challenge using Python.

```python
a ** b
```

2.) 

```python
pow (a,b,c)
# Returns (a ** b) % c
```

3.)

```python
n = 5147386106763423842
b = n.to_bytes(integer_value.bit_length(), byteorder='big')
ascii_string = b.decode(‘utf-8’)
print(ascii_string)
```

- .bit_length(): Used to find the number of bits required to represent the integer value. It calculates the minimum number of bits needed to represent the integer without leading zeros.
- byteorder=‘big’: This specifies the byte order, which is set to ‘big’. This means that the most significant byte will be at the lowest memory address.

4.)

```python
b = b'BabyBubbleBlue'
n = int.from_bytes(b, "big")
print(n)
```

### Flag 1 - bi0s{M4tH_fr35h3R}

5.)

```python
e = 65537 

n = 135771030095248564217333548708085976706635470201693382977359884405785053233624669209798488114332621251071896223046303890356177927260361922567255278263516431110348035912329968828255580422207058843539543230625164543967182776588191950617363654704483596433974410666274335878626712572583335642425654101905539235137 

b = b'CottonCandyCyan' 
plaintext = int.from_bytes(b,"big") 
ciphertext = pow(plaintext,e,n) 
print(ciphertext)
```

RSA encryption is done using the formula, 

Ci = (Pi ** e) mod n

6.)

```python
ct = 65730873122241583977501942857521551655862419814142537467794605641487141508168112705849405463650251324036527189894154256188004834922930955553552265141530965811260529590272915364722691816042276879149322147841179897567021900202362768433876414051764129620855986733911359793478284982158956094706335405419253842189

d = 8925128434164048909691892259170125764645191721432443785323614701213701263931531369772008639859571884469382029921205395235347940060683524698685287611143952365525998671937582532821556277881627223397225198920561405991438268419762030177758609618433197246606436834237687551093357836921900203688931921921080815809

n = 100004469514414305589755093689388362495734643502738599480039961817993219308305825163403681010510644997857734671729532909478372020474784776573386509518129821108046890669622337566827126774027510415874337068146526959087096766707185125814728908178444582703103893060931238382193718440117530400435153460058726227213

e = 65537
plaintext = pow(ct,d,n)

# Convert the decrypted integer to bytes and decode it

decoded_message = plaintext.to_bytes((plaintext.bit_length() + 7) // 8, byteorder=‘big’).decode(‘utf-8’)

# Print the decrypted message

print(decoded_message)
```

7.)

# Given values

```python
p = 285880804885505715088365434821249117591 
q = 223548505081667812376946559606986057893
```

# Calculate Euler’s Totient (φ)

```python
phi = (p - 1) * (q - 1)
print(phi)
```

8.)

```python
e = 65537 
phi = 6040530736567947369501159510312871912817682485385467038065939221077871371867752621870765479917330035438716285734316075589461070087125307656587738034549424
```

# Calculate the modular multiplicative inverse of e under phi (d)

```python
d = pow(e, -1, phi)
print(d)
```

9.)

# Given values

```python
c = 5119667904388996554913075691965298077574451428525647832421139040755532148564677239610936209568188199266675953600861923623367821617006732308102397661359638 
n = 6910782171213996658397253121710630123795235324197483219005527369298065059694620267925472189305202037262152652525687783466320955431741311010423968405213211
e = 65537
```

# Prime factors of n (p and q)

```python
p = 77875213153738183457169866835133610155772314072823133021250433414301022076677 
q = 88741743249819454803256128724422664779772307593666473114032370133748568669343
```

### *Found these prime factors using the website, factordb.com*

# Calculate Euler’s Totient (phi)

```python
phi = (p - 1) * (q - 1)
```

# Calculate the modular multiplicative inverse of e under phi (d)

```python
d = pow(e, -1, phi)
```

# Decrypt the ciphertext using RSA decryption

```python
m = pow(c, d, n)
```

# Convert the decrypted integer to bytes

```python
byte_data = m.to_bytes((m.bit_length() + 7) // 8, byteorder=‘big’)
```

# Convert bytes to ASCII string

```python
decoded_message = byte_data.decode(‘utf-8’)
print(decoded_message)
```

10.)

```python
import gmpy2
```

# Given values

```python
n = 117074712749243314104120206523208828239739356370813271231812420842659757427553455282559371215875081681811753738135075574497504999188420518925155046235035751639404389071835553732113704031110653016113481332938049250611262071285422427426607831948727746419318269434949378088634570780979492584407323665357971118667 

e = 3 

ct = 82895006021025315212194766818959778180071540025724099235413209819072766522409462780959875360431145495518560461472745549100306588074106771552399979846135716227942541180509399193416
```

# Decrypt the ciphertext by taking the cube root

```python
decrypted_message = gmpy2.iroot(ct, 3)[0]
```

# Convert the decrypted mpz object to a regular Python integer

```python
decrypted_integer = int(decrypted_message)
```

# Convert the decrypted integer to bytes and decode it

```python
decoded_message = decrypted_integer.to_bytes((decrypted_integer.bit_length() + 7) // 8, byteorder=‘big’).decode(‘utf-8’)
```

# Print the decrypted message

```python
print(“Decrypted message:”) print(decoded_message)
```

### Flag 3: bi0s{y0u_H4v3_gR4dU4t3d}

# Basic RSA in CTFs

```python
p = 141425761750882434366113656037465528064446934590747547591913071247558071478523067775424339379902549140682388121246592146755332109704901386671558886860468710289573558030527361687830155654271762079747974119304854799444200892494664030121777764817864236066664814388946471337642691402213002167546534086524889151493 

q = 157006051551554749447948461154166069280741233539909038877122296628155250472027778739586210291284924672264398178997704838753197073588553771894828080321619242495586214068036432855351448569359716239160693646942321157830455018125670551341322931414201893347339591241482474678282700265976542303742266087201779118319 

e = 65537 

signature = 2112725697240595792338701104840001143105965314009156886758430753729193280917949645949820751211929763090437984980301037272483245987121865425732864547619608106734040120161884684992084596683982376255405798908194228334042557434837256225901893398809467675789217016362545151175974485530888560500121637059987930493557119933717786703106790019551747187242238955973359471090349554986964676080526448248540408943974798265451208246715054141505165525705935485755789725530105006544991426436628768665983658789316761905500686591386455067164175303618412422630098909099013374440591654272123046548115834893961071864282501944948618397178

# Calculate modulus n
n = p * q

# Decrypt the signature to obtain the original message
original_message = pow(signature, e, n)

# Convert the decrypted integer to bytes
decoded_message = original_message.to_bytes(original_message.bit_length(), byteorder='big')
print(decoded_message)
```

### **flag: inctfj{bob_was_authenticated_by_alice}**
